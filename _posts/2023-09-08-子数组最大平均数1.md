643. 子数组最大平均数 I
简单

给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。
请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。
任何误差小于 10-5 的答案都将被视为正确答案。

示例 1：
输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75

示例 2：
输入：nums = [5], k = 1
输出：5.00000
 
提示：
n == nums.length
1 <= k <= n <= 105
-104 <= nums[i] <= 104

解答：
```
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int sum=0,len=nums.size();
        for(int i=0;i<k;i++){
            sum+=nums[i];
        }
        int tmp_sum=sum;
        for(int i=k;i<len;i++){
            tmp_sum+=nums[i]-nums[i-k];
            if(tmp_sum>sum){
                sum=tmp_sum;
            }
        }
        return (double)sum/k;
    }
};
```
说实话太简单了没什么好讲的
int->double 可以用强制类型转换或者1.0*num




关于accumulate函数：

这个函数是C++标准库中的`accumulate`函数，用于计算一个容器（例如`vector`或数组）中指定范围内元素的累加和。让我们逐步讲解这个函数的用法：

```cpp
int sum = accumulate(nums.begin(), nums.begin() + k, 0);
```

- `nums`是一个容器，它包含了要累加的元素。
- `nums.begin()`是容器的起始迭代器，它指向容器的第一个元素。
- `nums.begin() + k`是容器的终止迭代器，它指向要累加的元素的最后一个元素的下一个位置。
- `0`是累加的初始值，也就是累加和的起始值。

`accumulate`函数的工作方式是从指定范围的起始位置到终止位置，将元素一个个相加，并将结果存储在`sum`变量中。这意味着它会自动处理累加的循环，无需手动编写`for`循环。

关于效率的问题，`accumulate`函数通常不会比手动编写的`for`循环效率更高，因为它在内部仍然执行了类似于循环的操作。实际上，对于简单的累加操作，手动编写的`for`循环可能会更快，因为它避免了函数调用和迭代器操作的开销。

然而，`accumulate`函数的优势在于它的通用性和可读性。它可以用于各种不同类型的容器和累加操作，而不需要为每个情况都编写不同的循环。此外，它可以与其他STL算法结合使用，使代码更加模块化和可维护。

总之，`accumulate`函数通常用于提高代码的可读性和通用性，而不是为了性能优势。如果性能对于特定应用非常重要，而且您知道要累加的元素数量是有限的，那么手动编写`for`循环可能是一个更好的选择。
*Generated by ChatGPT*