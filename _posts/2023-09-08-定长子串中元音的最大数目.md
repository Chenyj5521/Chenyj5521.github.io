1456. 定长子串中元音的最大数目
中等

给你字符串 s 和整数 k 。
请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。
英文中的 元音字母 为（a, e, i, o, u）。

 
示例 1：
输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。

示例 2：
输入：s = "aeiou", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。

示例 3：
输入：s = "leetcode", k = 3
输出：2
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。

示例 4：
输入：s = "rhythms", k = 4
输出：0
解释：字符串 s 中不含任何元音字母。

示例 5：
输入：s = "tryhard", k = 4
输出：1
 
提示：

1 <= s.length <= 10^5
s 由小写英文字母组成
1 <= k <= s.length


思想：滑动窗口
和上一道一样，太简单，直接放代码
```
class Solution {
public:
inline bool IsVowel(char s){
    return s=='a'||s=='e'||s=='i'||s=='o'||s=='u';
}
    int maxVowels(string s, int k) {
        int len=s.size(),sum=0;
        for(int i=0;i<k;i++){
            if(IsVowel(s[i])){
                sum++;
            }
        }
        int tmp_sum=sum;
        for(int i=k;i<len;i++){
            if(IsVowel(s[i])){
                tmp_sum++;
            }
            if(IsVowel(s[i-k])){
                tmp_sum--;
            }
             if(tmp_sum>sum){
                sum=tmp_sum;
            }
        }
        return sum;
    }
};

```

力扣评论区解答（天才的思路）
```
class Solution {
public:
    int maxVowels(string s, int k) {
        vector<int> chars(26);
        chars['a' - 'a'] = 1;
        chars['e' - 'a'] = 1;
        chars['i' - 'a'] = 1;
        chars['o' - 'a'] = 1;
        chars['u' - 'a'] = 1;

        int maxRes = INT_MIN, res = 0;
        for (int i = 0; i < k; ++i) {
            res += chars[s[i] - 'a'];
        }
        maxRes = res;
        for (int i = k; i < s.size(); ++i) {
            res += (chars[s[i]-'a'] - chars[s[i-k]-'a']);
            if (maxRes < res) maxRes = res;
        }
        return maxRes;
    }
};

作者：linukey
链接：https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/2303284/1456-ding-chang-zi-chuan-zhong-yuan-yin-pwodx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


以下是算法的一些性能优势：

常数时间复杂度的查找：算法2使用一个长度为26的整数数组来存储元音字母的信息，这使得检查字符是否是元音字母的操作具有常数时间复杂度。相比之下，算法1每次都要调用IsVowel函数，这可能会导致更多的函数调用开销。
避免了不必要的重复计算：算法2在循环中只计算了字符增减的变化量，而不是重新计算整个窗口内的元音字母数量。这减少了不必要的计算，尤其是在窗口大小很大时。
使用了更紧凑的数据结构：算法2使用了一个整数数组，它在内存中的布局可能更紧凑，减少了缓存访问的开销。
*Generated by ChatGPT*
```

*还有优化思路：如果窗口里已经全部都是元音了，没必要把后面的都遍历一遍，我们已经得到结果了不是吗？这样的话， k 比较小的时候可能大大减少遍历的位置。*